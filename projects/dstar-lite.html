---
layout: project
title: Dynamic Obstacle Avoidance with D* Lite
project_id: EXP-25.01
permalink: /projects/dstar-lite.html

role: Course Project
timeline: Spring 2025
platform: TurtleBot3 Waffle, ROS 2
status: Completed

tech_stack:
- ROS 2 Foxy
- Navigation2
- D* Lite
- C++
- Gazebo 11
- RViz

github_url: https://github.com/thraj0103/dynamic_path_planning.git

hero_image: /img/featured/dstar-lite/hero.png
---

## MISSION_OBJECTIVE

<div class="content-block">
  <p><strong>TARGET:</strong> Implement the D* Lite incremental search algorithm as a custom ROS 2 Navigation2
    global planner plugin, enabling a TurtleBot3 to replan paths in real-time as dynamic obstacles appear in its
    environment.</p>

  <p><strong>CONSTRAINT:</strong> The planner must avoid full path recomputation on every obstacle event. Instead, it
    must reuse previous search state and only reprocess the <em>affected portions</em> of the map — achieving
    replanning speeds 10–100× faster than A* in dynamic scenarios.</p>
</div>

---

## SYSTEM_ARCHITECTURE

### [ ALGORITHM: D* LITE ]

<div class="content-block">
  <p>D* Lite is an incremental heuristic search algorithm that searches <strong>backwards from the goal to the
      start</strong>. When an obstacle is detected, instead of restarting, it selectively updates only the cells
    whose cost has changed and re-expands them from the priority queue.</p>
</div>

<ul class="feature-list">
  <li><strong>Priority Queue:</strong> Cells sorted by key function $k(s) = [\min(g(s), rhs(s)) + h(s_{start}, s) + k_m
    \;;\; \min(g(s), rhs(s))]$</li>
  <li><strong>State Variables:</strong> Each cell stores a $g$-value (current cost estimate) and $rhs$-value (one-step
    lookahead), enabling overconsistent/underconsistent classification.</li>
  <li><strong>Incremental Update:</strong> Only cells affected by costmap changes are re-queued and reprocessed.</li>
  <li><strong>Path Extraction:</strong> Follows decreasing $g$-values from start toward goal after search converges.
  </li>
</ul>

### [ NAV2 PLUGIN ARCHITECTURE ]

<ul class="feature-list">
  <li><strong>Interface:</strong> Implements <code>nav2_core::GlobalPlanner</code> with lifecycle methods:
    <code>configure()</code>, <code>activate()</code>, <code>deactivate()</code>, <code>cleanup()</code>,
    <code>createPlan()</code>.
  </li>
  <li><strong>Cell Representation:</strong> Custom struct storing position, $g$-value, $rhs$-value, and priority key.
  </li>
  <li><strong>Grid Map:</strong> Nested unordered map for O(1) cell lookup.</li>
  <li><strong>Costmap Integration:</strong> Subscribes to Nav2 layered costmap; lethal obstacles → infinite cost,
    inflation zones → high finite cost, free space → distance-based cost.</li>
</ul>

---

## EXECUTION_LOG

### 1. D* Lite Core: Key Function

<p>The priority key governs which cells are expanded first. It combines the current cost estimate with a heuristic and
  an accumulated key modifier $k_m$ (updated each time the robot moves):</p>

<div class="math-block">
  $$k(s) = \bigl[\min(g(s),\, rhs(s)) + h(s_{start}, s) + k_m \;;\; \min(g(s),\, rhs(s))\bigr]$$
</div>

### 2. Nav2 Plugin: createPlan()

<div class="code-window">
  <div class="code-window__header">
    <span class="code-window__title">dstar_lite_planner.cpp</span>
    <span class="code-window__status">● ACTIVE</span>
  </div>
  <pre class="code-window__content"><code>nav_msgs::msg::Path DStarLitePlanner::createPlan(
    const geometry_msgs::msg::PoseStamped& start,
    const geometry_msgs::msg::PoseStamped& goal)
{
    if (first_run_) {
        initialize(start, goal);
        computeShortestPath();
        first_run_ = false;
    } else if (costmap_changed_) {
        // Only reprocess affected cells — no full replan
        for (auto& cell : changed_cells_) {
            updateVertex(cell);
        }
        computeShortestPath();
    }
    return extractPath(start, goal);
}</code></pre>
</div>


---

## RESULTS

<div class="content-block">
  <p>The D* Lite planner was evaluated across three scenarios — sudden obstacle placement, previously occluded
    obstacles revealed during navigation, and obstacles spawned in close proximity to the robot. In all three cases
    the planner successfully detected the change and replanned a viable path in real-time without full
    recomputation, demonstrating the algorithm's core advantage over A* and Dijkstra's in dynamic environments.</p>
</div>

---


## ANOMALY_REPORT

<div class="alert-box alert-danger">
  <h4>CHALLENGE: Priority Queue Inefficiency</h4>

  <p><strong>ISSUE:</strong> Standard C++ <code>std::priority_queue</code> does not support in-place key updates.
    When a cell's cost changes, the queue had to be rebuilt, causing significant slowdown during frequent
    replanning.</p>

  <p><strong>SOLUTION:</strong> Implemented a custom priority queue using an auxiliary unordered map to track all
    elements currently in the queue, enabling O(1) key updates via lazy deletion and re-insertion.</p>

  <p><strong>OUTCOME:</strong> 3× speedup in update operations; sustained real-time replanning performance throughout
    all three test cases.</p>
</div>